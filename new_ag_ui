# ag_ui_adapter.py
import os
import json
import asyncio
import time
import uuid
import re
from typing import AsyncGenerator, List

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware

from client import FlightOpsMCPClient, extract_flight_details_from_query
import logging

app = FastAPI(title="FlightOps — AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

# Setup logging
logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger(__name__)

# Utility to format SSE data
def sse_event(data: dict) -> str:
    payload = json.dumps(data, default=str, ensure_ascii=False)
    return f"data: {payload}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    # Try pre-connecting to MCP so first requests are faster
    try:
        await ensure_mcp_connected()
    except Exception as e:
        logger.warning(f"Could not preconnect to MCP: {e}")

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

def determine_tool_from_query(query: str) -> str:
    """
    Determine which tool to use based on query content
    """
    query_lower = query.lower()

    if any(word in query_lower for word in ['delay', 'late', 'on-time', 'punctual']):
        return "get_delay_summary"
    elif any(word in query_lower for word in ['time', 'schedule', 'departure', 'arrival', 'operation']):
        return "get_operation_times"
    elif any(word in query_lower for word in ['equipment', 'aircraft', 'tail', 'plane']):
        return "get_equipment_info"
    elif any(word in query_lower for word in ['fuel', 'consumption']):
        return "get_fuel_summary"
    elif any(word in query_lower for word in ['passenger', 'pax']):
        return "get_passenger_info"
    elif any(word in query_lower for word in ['crew', 'pilot', 'staff']):
        return "get_crew_info"
    else:
        return "get_flight_basic_info"

# -------------------------
# Direct-flight endpoints (no LLM)
# -------------------------
@app.post("/direct-flight-query")
async def direct_flight_query(request: Request):
    """
    Direct flight query without LLM planning.
    Body: { "query": "<user text>" }
    Returns route-selection if multiple matching documents found, otherwise returns the single document result.
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    user_query = body.get("query", "") or ""
    if not user_query.strip():
        raise HTTPException(status_code=400, detail="No query provided")

    # Extract flight details (carrier, flight_number, date_of_origin)
    flight_details = extract_flight_details_from_query(user_query)
    tool_name = determine_tool_from_query(user_query)

    try:
        await ensure_mcp_connected()
    except Exception as e:
        return {"success": False, "error": f"MCP connection failed: {e}"}

    # Use client's direct handler that already implements multi-doc detection and returns structured result
    try:
        result = await mcp_client.handle_flight_query_direct(user_query, tool_name, flight_details)
        return {"success": True, "data": result}
    except Exception as e:
        logger.exception("direct_flight_query failed")
        return {"success": False, "error": str(e)}

@app.post("/select-route")
async def select_route(request: Request):
    """
    Handle user route selection after direct-flight-route list was shown.
    Body: { "tool_name": "...", "tool_args": {...}, "selected_route": {"startStation": "...", "endStation": "..."} }
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    tool_name = body.get("tool_name")
    tool_args = body.get("tool_args", {})
    selected_route = body.get("selected_route", {})

    if not tool_name or not selected_route:
        raise HTTPException(status_code=400, detail="tool_name and selected_route required")

    try:
        await ensure_mcp_connected()
        result = await mcp_client.get_documents_by_route_selection(tool_name, tool_args, selected_route)
        return {"success": True, "data": result}
    except Exception as e:
        logger.exception("select_route failed")
        return {"success": False, "error": str(e)}

# -------------------------
# AG-UI /agent endpoint (streaming)
# -------------------------
@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])

    # determine user query — prefer last user message
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "")
        elif isinstance(last, str):
            user_query = last

    if not user_query or not user_query.strip():
        raise HTTPException(status_code=400, detail="No user query in messages payload")

    # Determine if this is a flight query that can be handled directly
    is_flight_query = any(keyword in user_query.lower() for keyword in
                         ['flight', '6e', 'carrier', 'delay', 'time', 'equipment', 'fuel', 'passenger', 'crew'])

    if is_flight_query:
        # Use lightweight direct flow (no LLM planning) and stream back SSE events
        return await handle_direct_flight_query(user_query, thread_id, run_id)
    else:
        # Use LLM-based handling
        return await handle_llm_based_query(user_query, thread_id, run_id, request)

# ---- Direct flight SSE handler (no LLM) ----
async def handle_direct_flight_query(user_query: str, thread_id: str, run_id: str):
    async def event_stream() -> AsyncGenerator[str, None]:
        # RUN_STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})

        # THINKING
        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {"phase": "thinking", "progress_pct": 10, "message": "Analyzing flight query..."}
        })

        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        # extract details and pick a tool
        flight_details = extract_flight_details_from_query(user_query)
        tool_name = determine_tool_from_query(user_query)

        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {"phase": "processing", "progre
